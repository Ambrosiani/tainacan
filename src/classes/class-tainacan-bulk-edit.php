<?php

namespace Tainacan;
use Tainacan\Repositories;
use Tainacan\Entities;

defined( 'ABSPATH' ) || exit;

/**
 * Bulk_Edit class handles bulk item edition
 */
class Bulk_Edit  {
	
	private $meta_key = '_tnc_bulk';
	
	/**
	 * The ID of the current bulk edition group.
	 * @var string
	 */
	private $id;
	
	/**
	 * Initializes a bulk edit object
	 *
	 * This object have an ID that identifies the group of selected items that are to be affected by the changes.
	 *
	 * When itialized it adds a postmeta to the posts of these groups so they can be easily fetched as a group in all operations.
	 *
	 * The object can be initialized in three different ways:
	 * 1. passing an array of Items IDs, using the items_ids params
	 * 2. passing a query array, that will be passed to the fetch method of items repository to create the group  (in this case you also need to inform the collection id) 
	 * 3. passing an group ID, generated by this class in a previous initialization using one of the methods above.
	 *
	 * When initializing using methods 1 or 2, controllers should then call the get_id() method and store it if they want to perform future requests that wil affect this same group of items
	 *
	 * Note: if the ID paramater is passed, other paramaters will be ignored.
	 * 
	 * @param  array $params {
	 * 
	 * 		Initialization paramaters
	 *
	 * 		@type int 		$collection_id  The items collection ID. Required if initializing using a query search
	 * 		@type array 	$query The query paramaters used to fetch items that will be part of this bulk edit group
	 * 		@type array 	$items_ids an array containing the IDs of items that will be part of this bulk edit group
	 * 		@type string 	$id The ID of the Bulk edit group.
	 * 
	 * }
	 */
	public function __construct($params) {
		
		if (isset($params['id']) && !empty($params['id'])) {
			$this->id = $params['id'];
			return;
		}
		
		global $wpdb;
		
		$id = uniqid();
		$this->id = $id;

		if (isset($params['query']) && is_array($params['query'])) {
			
			if (!isset($params['collection_id']) || !is_integer($params['collection_id'])) {
				throw new \Exception('Collection ID must be informed when creating a group via query');
			}
			
			/**
			 * Here we use the fetch method to parse the parameter and use WP_Query
			 *
			 * However, we add a filter so the query is not executed. We just want WP_Query to build it for us
			 * and then we can use it to INSERT the postmeta with the bulk group ID
			 */
			
			// this avoids wp_query to run the query. We just want to build the query
			add_filter('posts_pre_query', '__return_empty_array');
			
			// this adds the meta key and meta value to the SELECT query so it can be used directly in the INSERT below
			add_filter('posts_fields_request', [&$this, 'add_fields_to_query'], 10, 2);
			
			$itemsRepo = Repositories\Items::get_instance();
			$params['query']['fields'] = 'ids';
			$items_query = $itemsRepo->fetch($params['query'], $params['collection_id']);
			
			remove_filter('posts_pre_query', '__return_empty_array');
			remove_filter('posts_fields_request', [&$this, 'add_fields_to_query']);
			
			$wpdb->query( "INSERT INTO $wpdb->postmeta (post_id, meta_key, meta_value) {$items_query->request}" );
			
			return;
			
		} elseif (isset($params['items_ids']) && is_array($params['items_ids'])) {
			$items_ids = array_filter($params['items_ids'], 'is_integer');
			
			$insert_q = '';
			foreach ($items_ids as $item_id) {
				$insert_q .= $wpdb->prepare( "(%d, %s, %s),", $item_id, $this->meta_key, $this->get_id() );
			}
			$insert_q = rtrim($insert_q, ',');
			
			$wpdb->query( "INSERT INTO $wpdb->postmeta (post_id, meta_key, meta_value) VALUES $insert_q" );
			
			return;
			
		}
		
	}
	
	/**
	 * Internally used to filter WP_Query and build the INSERT statement. 
	 * Must be public becaus is registered as a filter callback
	 */
	public function add_fields_to_query($fields, $wp_query) {
		global $wpdb;
		if ( $wp_query->get('fields') == 'ids' ) { // just to make sure we are in the right query
			$fields .= $wpdb->prepare( ", %s, %s", $this->meta_key, $this->get_id() );
		}
		return $fields;
	}
	
	/**
	 * Get the current group ID
	 * @return string the group ID
	 */
	public function get_id() {
		return $this->id;
	}
	
	// return the number of items selected in the current bulk group
	public function count_posts() {
		global $wpdb;
		$id = $this->get_id();
		if (!empty($id)) {
			return $wpdb->get_var( $wpdb->prepare("SELECT COUNT(post_id) FROM $wpdb->postmeta WHERE meta_key = %s AND meta_value = %s", $this->meta_key, $id) );
		}
		return 0;
	}

	private function _build_select($fields) {
		global $wpdb;

		return $wpdb->prepare( "SELECT $fields FROM $wpdb->postmeta WHERE meta_key = %s AND meta_value = %s", $this->meta_key, $this->get_id() );

	}

	public function add_value(Entities\Metadatum $metadatum, $value) {

		if (!$this->get_id()) {
			return false;
		}

		// Specific validation
		if (!$metadatum->is_multiple()) {
			return ['error' => __('Unable to add a value to a metadata if it does not accepts multiple values', 'tainacan')];
		}
		if ($metadatum->is_collection_key()) {
			return ['error' => __('Unable to add a value to a metadata set to be a collection key', 'tainacan')];
		}

		$dummyItem = new Entities/Item();
		$checkItemMetadata = new Entities\Item_Metadata_Entity($dummyItem, $metadatum);
		$checkItemMetadata->set_value([$value]);

		if ($checkItemMetadata->validate()) {
			$this->_add_value($metadatum, $value);
		} else {
			return ['error' => __('Invalid value', 'tainacan')];
		}


	}

	public function set_value(Entities\Metadatum $metadatum, $value) {

		if (!$this->get_id()) {
			return false;
		}

		// Specific validation
		
		if ($metadatum->is_collection_key()) {
			return ['error' => __('Unable to set a value to a metadata set to be a collection key', 'tainacan')];
		}

		$dummyItem = new Entities/Item();
		$checkItemMetadata = new Entities\Item_Metadata_Entity($dummyItem, $metadatum);
		$checkItemMetadata->set_value( $metadatum->is_multiple() ? [$value] : $value );

		if ($checkItemMetadata->validate()) {
			$this->_delete_values($metadatum);
			return $this->_add_value($metadatum, $value);
		} else {
			return ['error' => __('Invalid value', 'tainacan')];
		}


	}

	public function replace_value(Entities\Metadatum $metadatum, $old_value, $new_value) {

		if (!$this->get_id()) {
			return false;
		}

		// Specific validation
		
		if ($metadatum->is_collection_key()) {
			return ['error' => __('Unable to set a value to a metadata set to be a collection key', 'tainacan')];
		}

		$dummyItem = new Entities/Item();
		$checkItemMetadata = new Entities\Item_Metadata_Entity($dummyItem, $metadatum);
		$checkItemMetadata->set_value( $metadatum->is_multiple() ? [$new_value] : $new_value );

		if ($checkItemMetadata->validate()) {
			$this->_delete_value($metadatum, $old_value);
			return $this->_add_value($metadatum, $new_value);
		} else {
			return ['error' => __('Invalid value', 'tainacan')];
		}


	}


	/**
	 * Adds a value to the current group of items
	 * 
	 * This method adds value to the database directly, any check or validation must be done beforehand
	 */
	private function _add_value(Entities\Metadatum $metadatum, $value) {

		$type = $metadatum->get_metadata_type_object();

		if ($type->primitive_type == 'term') {

			$options = $metadatum->get_metadata_type_options();
			$taxonomy_id = $options['taxonomy_id'];
			$tax = Repositories\Taxonomies::get_instance()->fetch($taxonomy_id);

			if ($tax instanceof Entities\Taxonoy) {

				$term = term_exists($value, $tax->get_db_identifier());

				if (!is_array($term)) {
					$term = wp_insert_term($value, $tax->get_db_identifier());
				}

				if (is_wp_error($term) || !isset($term['term_taxonomy_id'])) {
					return false;
				}

				$insert_q = $this->_build_select( $wpdb->prepare("post_id, %d", $term['term_taxonomy_id']) );

				$query = "INSERT INTO $wpdb->term_relationship (object_id, term_taxonomy_id) $insert_q";

				return $wpdb->query($query);

				//TODO update term count


			}

		} else {

			global $wpdb;

			$insert_q = $this->_build_select( $wpdb->prepare("post_id, %s, %s", $metadatum->get_id(), $value) );

			$query = "INSERT INTO $wpdb->postmeta (post_id, meta_key, meta_value) $insert_q";

			return $wpdb->query($query);

		}

		return false;

	}

	/**
	 * Removes a value from the current group of items
	 * 
	 * This method removes value from the database directly, any check or validation must be done beforehand
	 */
	private function _delete_value(Entities\Metadatum $metadatum, $value) {

		$type = $metadatum->get_metadata_type_object();

		if ($type->primitive_type == 'term') {

			$options = $metadatum->get_metadata_type_options();
			$taxonomy_id = $options['taxonomy_id'];
			$tax = Repositories\Taxonomies::get_instance()->fetch($taxonomy_id);

			if ($tax instanceof Entities\Taxonoy) {

				$term = term_exists($value, $tax->get_db_identifier());

				if (!is_array($term)) {
					$term = wp_insert_term($value, $tax->get_db_identifier());
				}

				if (is_wp_error($term) || !isset($term['term_taxonomy_id'])) {
					return false;
				}

				$delete_q = $this->_build_select( "post_id" );

				$query = $wpdb->prepare( "DELETE FROM $wpdb->term_relationship WHERE term_taxonomy_id = %d AND object_id IN ($delete_q)", $term['term_taxonomy_id'] );

				return $wpdb->query($query);

				//TODO update term count

			}

		} else {

			global $wpdb;

			$delete_q = $this->_build_select( "post_id" );

			$query = $wpdb->prepare( "DELETE FROM $wpdb->postmeta WHERE meta_key = %s AND meta_value = %s AND post_id IN ($delete_q)", $metadatum->get_id(), $value );

			return $wpdb->query($query);

		}

		return false;

	}

	/**
	 * Removes all values of a metadatum from the current group of items
	 * 
	 * This method removes value from the database directly, any check or validation must be done beforehand
	 */
	private function _delete_values(Entities\Metadatum $metadatum) {

		$type = $metadatum->get_metadata_type_object();

		if ($type->primitive_type == 'term') {

			$options = $metadatum->get_metadata_type_options();
			$taxonomy_id = $options['taxonomy_id'];
			$tax = Repositories\Taxonomies::get_instance()->fetch($taxonomy_id);

			if ($tax instanceof Entities\Taxonoy) {

				$delete_q = $this->_build_select( "post_id" );
				$delete_tax_q = $wpdb->prepare( "SELECT term_taxonomy_id FROM $wpdb->term_taxonomy WHERE taxonomy = %s" , $tax->get_db_identifier() );

				$query = $wpdb->prepare( "DELETE FROM $wpdb->term_relationship WHERE term_taxonomy_id IN ($delete_tax_q) AND object_id IN ($delete_q)" );

				return $wpdb->query($query);

				//TODO update term count

			}

		} else {

			global $wpdb;

			$delete_q = $this->_build_select( "post_id" );

			$query = $wpdb->prepare( "DELETE FROM $wpdb->postmeta WHERE meta_key = %s AND post_id IN ($delete_q)", $metadatum->get_id() );

			return $wpdb->query($query);

		}

		return false;

	}
	
	
	
}